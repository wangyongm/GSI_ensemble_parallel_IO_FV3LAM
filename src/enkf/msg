controlvec.f90
56c56
<                      fgsfcfileprefixes, paranc, write_fv3_incr, write_ensmean
---
>                      fgsfcfileprefixes, paranc, write_fv3_incr
294,295c294
< real(r_single), allocatable, dimension(:,:) :: grdin_mean_tmp
< real(r_single), allocatable, dimension(:,:,:,:) :: grdin_mean
---
> real(r_single), allocatable, dimension(:,:) :: grdin_mean, grdin_mean_tmp
301c300
<      allocate(grdin_mean(npts,ncdim,nbackgrounds,1))
---
>      allocate(grdin_mean(npts,ncdim))
315c314
<          if (nproc == 0) grdin_mean(:,:,nb,1) = grdin_mean(:,:,nb,1) + grdin_mean_tmp
---
>          if (nproc == 0) grdin_mean = grdin_mean + grdin_mean_tmp
319c318
<          grdin_mean(:,:,nb,1) = grdin_mean(:,:,nb,1)/real(nanals)
---
>          grdin_mean = grdin_mean/real(nanals)
322,323c321,322
<                 minval(grdin_mean(:,clevels(nvar-1)+1:clevels(nvar),nb,1)),     &
<                 maxval(grdin_mean(:,clevels(nvar-1)+1:clevels(nvar),nb,1))
---
>                 minval(grdin_mean(:,clevels(nvar-1)+1:clevels(nvar))),     &
>                 maxval(grdin_mean(:,clevels(nvar-1)+1:clevels(nvar)))
327,328c326,327
<                 minval(grdin_mean(:,clevels(nc3d) + nvar,nb,1)),                &
<                 maxval(grdin_mean(:,clevels(nc3d) + nvar,nb,1))
---
>                 minval(grdin_mean(:,clevels(nc3d) + nvar)),                &
>                 maxval(grdin_mean(:,clevels(nc3d) + nvar))
332a332,334
>    if (nproc == 0) then
>       deallocate(grdin_mean)
>    endif
354,361d355
<       if (nproc == 0 .and. write_ensmean) then
<          ! write_ensmean implies use_qsatensmean
<          do nb=1,nbackgrounds
<             ! re-scale normalized spfh with sat. sphf of ensmean first guess
<             grdin_mean(:,(q_ind-1)*nlevs+1:q_ind*nlevs,nb,1) = &
<             grdin_mean(:,(q_ind-1)*nlevs+1:q_ind*nlevs,nb,1)*qsatmean(:,:,nb)
<          enddo
<       endif
370,378d363
<         if (write_ensmean) then
<            ! also write out ens mean on root task.
<            if (write_fv3_incr) then
<               call writeincrement(0,0,cvars3d,cvars2d,nc3d,nc2d,clevels,ncdim,grdin_mean,no_inflate_flag)
<            else
<               call writegriddata(0,0,cvars3d,cvars2d,nc3d,nc2d,clevels,ncdim,grdin_mean,no_inflate_flag)
<            end if
<         endif
<         deallocate(grdin_mean)
393,401d377
<      ! also write out ens mean on root task
<      if (write_ensmean) then ! FIXME use parallel IO to write ensmean
<         if (write_fv3_incr) then
<            call writeincrement(0,0,cvars3d,cvars2d,nc3d,nc2d,clevels,ncdim,grdin_mean,no_inflate_flag)
<         else
<            call writegriddata(0,0,cvars3d,cvars2d,nc3d,nc2d,clevels,ncdim,grdin_mean,no_inflate_flag)
<         end if
<      endif
<      deallocate(grdin_mean)
covlocal.f90
enkf.f90
126c126
<                   anal_ob,anal_ob_post,assimltd_flag
---
>                   anal_ob
132c132
<                   iseed_perturbed_obs,lupd_obspace_serial,efsoi_cycling,&
---
>                   iseed_perturbed_obs,lupd_obspace_serial,fso_cycling,&
134d133
< 
156,157c155
<                 niter,i,nrej,npt,nuse,ncount,ncount_check,nb,np,&
<                 nuseconvoz,nusesat,nobs_convoz
---
>                 niter,i,nrej,npt,nuse,ncount,ncount_check,nb,np
694c692,698
<                  ensmean_obchunk(nob2) = ensmean_obchunk(nob2) + kfgain*obinc_tmp
---
>                  nob3 = indxproc_obs(nproc+1,nob2)
>                  if(TRIM(obtype(nob3)) .eq. 'dbz' ) then
>                     ensmean_obchunk(nob2) = MAX((ensmean_obchunk(nob2) + &
>                                             kfgain*obinc_tmp),zero)
>                  else
>                     ensmean_obchunk(nob2) = ensmean_obchunk(nob2) + kfgain*obinc_tmp
>                  end if
720c724,730
<                   ensmean_obchunk(nob2) = ensmean_obchunk(nob2) + kfgain*obinc_tmp
---
>                   nob3 = indxproc_obs(nproc+1,nob2)
>                   if(TRIM(obtype(nob3)) .eq. 'dbz' ) then
>                        ensmean_obchunk(nob2) = MAX((ensmean_obchunk(nob2) + &
>                                                kfgain*obinc_tmp),zero)
>                   else
>                       ensmean_obchunk(nob2) = ensmean_obchunk(nob2) + kfgain*obinc_tmp
>                   end if
771,773d780
<       if(allocated(assimltd_flag))deallocate(assimltd_flag)
<       allocate(assimltd_flag(nobstot))
<       assimltd_flag = 99999
780,781d786
<       nuseconvoz=0; nusesat = 0
<       nobs_convoz = nobs_conv + nobs_oz
787,796d791
<             assimltd_flag(nob) = 1
<             if (nob .le. nobs_convoz) then
<                nuseconvoz = nuseconvoz +1
<             else if (nob .gt. nobs_convoz) then
<                nusesat = nusesat + 1
<             else
<                print *,'nob ', nob ,' falling through'
<             endif
<          else
<             assimltd_flag(nob) = 0
805,806d799
<       if (nuseconvoz > 0 ) print *,nuseconvoz,' out of',nobs_conv + nobs_oz ,'convobs used'
<       if (nusesat > 0 ) print *,nusesat ,' out of',nobs_sat ,'satobs used'
857c850
< if(efsoi_cycling) then  
---
> if(fso_cycling) then  
862c855
<       allocate(anal_ob_post(1:nanals,nobstot))   
---
>       allocate(anal_ob(1:nanals,nobstot))   
869c862
<             anal_ob_post(:,nob2) = buffertmp3(:,nob1)   
---
>             anal_ob(:,nob2) = buffertmp3(:,nob1)   
874c867
<          anal_ob_post(:,nob2) = anal_obchunk(:,nob1)   
---
>          anal_ob(:,nob2) = anal_obchunk(:,nob1)   
enkf_main.f90
79c79
<                     lobsdiag_forenkf, netcdf_diag, efsoi_cycling, ntasks_io
---
>                     lobsdiag_forenkf, netcdf_diag, fso_cycling, ntasks_io
186c186
<  if(efsoi_cycling) call init_ob_sens()
---
>  if(fso_cycling) call init_ob_sens()
219c219
<  if(efsoi_cycling) then
---
>  if(fso_cycling) then
243c243
<  if(efsoi_cycling) call print_ob_sens()
---
>  if(fso_cycling) call print_ob_sens()
271c271
<  if(efsoi_cycling) call destroy_ob_sens()
---
>  if(fso_cycling) call destroy_ob_sens()
enkf_obsmod.f90
95d94
< !   2019-03-21  CAPS(C. Tong) - added the code for direct reflecitivity DA capability
108c107
<       letkf_flag,nobsl_max,datestring,datapath,sprd_tol,nanals,saterrfact, &
---
>       datestring,datapath,sprd_tol,nanals,saterrfact, &
113,116c112
<       lnsigcutoffpsnh, lnsigcutoffpssh, lnsigcutoffpstr, neigv, &
<       lnsigcutoffrdrnh, lnsigcutoffrdrsh, lnsigcutoffrdrtr,&
<       corrlengthrdrnh, corrlengthrdrtr, corrlengthrdrsh,   &
<       l_use_enkf_directZDA
---
>       lnsigcutoffpsnh, lnsigcutoffpssh, lnsigcutoffpstr, neigv
153,158d148
< ! ob-space posterior ensemble, needed for EFSOI
< real(r_single),public,allocatable, dimension(:,:) :: anal_ob_post   ! Fortran pointer
< ! is the observation assimilated? logical would be preferable, but that confuses
< ! Python
< integer(i_kind),public,allocatable, dimension(:) :: assimltd_flag ! Fortran pointer
< 
210,216d199
<  print *,'min/max obtime ',minval(obtime),maxval(obtime)
< endif
< ! if nobsl_max set for LETKF, and the total number of obs < nobsl_max,
< ! reset nobsl_max to -1
< if (letkf_flag .and. nobsl_max > 0 .and. nobstot < nobsl_max) then
<    if (nproc == 0) print *,'resetting nobsl_max to -1'
<    nobsl_max=-1
280,281d262
<    else if ( (obtype(nob)(1:3) == 'dbz' .or. obtype(nob)(1:3) == ' rw') .and. l_use_enkf_directZDA ) then
<       lnsigl(nob) = latval(deglat,lnsigcutoffrdrnh,lnsigcutoffrdrtr,lnsigcutoffrdrsh)
287,289d267
<    if ( (obtype(nob)(1:3) == 'dbz' .or. obtype(nob)(1:3) == ' rw') .and. l_use_enkf_directZDA ) then
<        corrlengthsq(nob)=latval(deglat,corrlengthrdrnh,corrlengthrdrtr,corrlengthrdrsh)**2
<    end if
478,479d455
< if (allocated(anal_ob_post)) deallocate(anal_ob_post)
< if (allocated(assimltd_flag)) deallocate(assimltd_flag)
enkf_obs_sensitivity.f90
21d20
< !   adloc_chunk - Coordinates of observation response
36c35
< use params, only: efsoi_flag,latbound,nlevs,nanals,datestring, &
---
> use params, only: fso_calculate,latbound,nlevs,nanals,datestring, &
42c41
<                   nbackgrounds,adrate,eft
---
>                   nbackgrounds
47,48c46,47
<                        oberrvar_orig,biaspreds,anal_ob_post,nobstot,lnsigl, &
<                        corrlengthsq,obtimel,oblnp,obloc ,assimltd_flag
---
>                        oberrvar_orig,biaspreds,anal_ob,nobstot,lnsigl, &
>                        corrlengthsq,obtimel,oblnp,obloc
51a51
> use gridinfo, only: latsgrd,lonsgrd,nlevs_pres,npts
60c60
<        obsense_kin,obsense_dry,obsense_moist,adloc_chunk
---
>        obsense_kin,obsense_dry,obsense_moist
63d62
< real(r_single),allocatable,dimension(:,:) :: adloc_chunk
94d92
<   integer(i_kind) :: assimltd_flag      ! is assimilated? flag
102d99
< 
135d131
< 
195c191
< 
---
>  ! nobstot=nobsgood
197,203d192
<   if(nproc == 0) write(6,*) 'total number of conv obs ',nobs_conv
<   if(nproc == 0) write(6,*) 'total number of oz obs',nobs_oz
<   if(nproc == 0) write(6,*) 'total number of sat obs',nobs_sat
<   if(nproc == 0) write(6,*) 'npred=',inhead%npred
<   if(nproc == 0) write(6,*) 'idate=',inhead%idate
<   if(nproc == 0) write(6,*) 'nanals=',inhead%nanals
< 
219d207
<   allocate(assimltd_flag(nobstot))
223c211
<   if(nproc == 0) allocate(anal_ob_post(nanals,nobstot))
---
>   if(nproc == 0) allocate(anal_ob(nanals,nobstot))
240,241c228
<      assimltd_flag(nob) = indata%assimltd_flag
<      if(nproc == 0) anal_ob_post(1:nanals,nob) = real(tmpanal_ob(1:nanals),r_kind)
---
>      if(nproc == 0) anal_ob(1:nanals,nob) = real(tmpanal_ob(1:nanals),r_kind)
262,263c249
<      assimltd_flag(nob) = indata%assimltd_flag
<      if(nproc == 0) anal_ob_post(1:nanals,nob) = real(tmpanal_ob(1:nanals),r_kind)
---
>      if(nproc == 0) anal_ob(1:nanals,nob) = real(tmpanal_ob(1:nanals),r_kind)
349c335
<   if(efsoi_flag) then
---
>   if(fso_calculate) then
437,438c423
<         outdata%assimltd_flag = assimltd_flag(nob)
<         if(efsoi_flag) then
---
>         if(fso_calculate) then
447c432
<         tmpanal_ob(1:nanals) = real(anal_ob_post(1:nanals,nob),r_single)
---
>         tmpanal_ob(1:nanals) = real(anal_ob(1:nanals,nob),r_single)
449c434
<         if(.not. efsoi_flag) cycle
---
>         if(.not. fso_calculate) cycle
466c451
<      if(efsoi_flag) then
---
>      if(fso_calculate) then
507,508c492
<         outdata%indxsat = nchan
<         outdata%assimltd_flag = assimltd_flag(nob)
---
>         outdata%indxsat = nuchan(nchan)
510c494
<         if(efsoi_flag) then
---
>         if(fso_calculate) then
519c503
<         tmpanal_ob(1:nanals) = real(anal_ob_post(1:nanals,nob),r_single)
---
>         tmpanal_ob(1:nanals) = real(anal_ob(1:nanals,nob),r_single)
521c505
<         if(.not. efsoi_flag) cycle
---
>         if(.not. fso_calculate) cycle
540c524
<      if(efsoi_flag) then
---
>      if(fso_calculate) then
584d567
<   if(allocated(adloc_chunk)) deallocate(adloc_chunk)
expand_ens.f90
fftpack.f90
genqsat1.f90
gridinfo_fv3reg.f90
38d37
< !   2021-02-08  CAPS(J. Park) - Modified 'vars3d_supported' for direct reflectivity DA capability
45c44,45
< use mpisetup, only: nproc, mpi_integer, mpi_real4, mpi_comm_world
---
> use mpisetup, only: nproc, mpi_integer, mpi_real4 
> use mpimod, only: mpi_comm_world
47c47
<                   fv3fixpath, nx_res,ny_res, ntiles
---
>                   fv3fixpath, nx_res,ny_res, ntiles, if_adaptive_inflate
66c66
< real(r_single),public, allocatable, dimension(:,:) :: logp
---
> real(r_single),public, allocatable, dimension(:,:) :: logp, inflation_mask
71,72c71,72
< character(len=max_varname_length),public, dimension(16) :: vars3d_supported = (/'u   ', 'v   ', 'w ', 't ', 'q   ', 'oz  ', 'cw  ', 'tsen', 'prse', &
<                                                                                 'ql  ', 'qi  ', 'qr', 'qs', 'qg', 'qnr', 'dbz'/)
---
> character(len=max_varname_length),public, dimension(13) :: vars3d_supported = (/'u   ', 'v   ', 't   ', 'q   ', 'oz  ', 'ql  ', 'tsen', 'qr  ', &
>                                                                                 'qs  ', 'qi  ', 'qg  ', 'dbz ', 'w   '  /)
98c98
< real(r_single), allocatable, dimension(:,:,:) :: delp,g_prsi
---
> real(r_single), allocatable, dimension(:,:,:) :: delp,g_prsi,vartemp
104,105d103
< logical  :: if_file_exist
< 
217c215
<       filename = 'fv3sar_tile'//char_tile//"_ensmean_dynvartracer"
---
>       filename = 'fv3sar_tile'//char_tile//"_ensmean_dynvar"
219,222d216
<       inquire(file=filename, exist=if_file_exist)
<       if ( .not. if_file_exist )then
<          filename = 'fv3sar_tile'//char_tile//"_ensmean_dynvar"
<       end if
272a267,295
> 
>    if( if_adaptive_inflate )then
>       allocate(vartemp(nx_res,ny_res,nlevs))
>       allocate(inflation_mask(npts,nlevs))
>       nn = 0
>       do ntile=1,ntiles
>          nn_tile0=(ntile-1)*nx_res*ny_res
>          nn=nn_tile0
>          write(char_tile, '(i1)') ntile
>          filename='fv3sar_tile'//char_tile//'_mask'
>          call nc_check(nf90_open( trim(adjustl(filename)),nf90_nowrite,file_id),&
>          myname_,'open: '//trim(adjustl(filename)) )
>          call read_fv3_restart_data3d('W',filename,file_id,vartemp)
>          call nc_check( nf90_close(file_id),&
>          myname_,'close '//trim(filename) )
>          do k=1,nlevs
>             nn = nn_tile0
>             do j=1,ny_res
>               do i=1,nx_res
>                  nn=nn+1
>                  inflation_mask(nn,k)=vartemp(i,j,k)
>               enddo
>             enddo
>          enddo
>      end do
>      deallocate(vartemp)
> 
>    end if
> 
284a308
>    if( if_adaptive_inflate ) allocate(inflation_mask(npts,nlevs))
289a314,318
> if( if_adaptive_inflate ) then
>   do k=1,nlevs
>      call mpi_bcast(inflation_mask(1,k),npts,mpi_real4,0,MPI_COMM_WORLD,ierr)
>   end do
> end if
gridinfo_gfs.f90
gridinfo_nmmb.f90
gridinfo_wrf.f90
gridio_fv3reg.f90
21,25d20
<   !   2021-02-08 CAPS (C. Tong and J. Park)
<   !                   -- add variables for direct reflectivitiy DA capability
<   !                      (hydrometeors and 'w')
<   !                   -- add code to update 'delp' directly 
<   !                      from analysis icnrements
39c34
<   use params,   only:  pseudo_rh, l_use_enkf_directZDA
---
>   use params,   only:  pseudo_rh
56a52
>   ! Generic WRF read routine, calls ARW-WRF or NMM-WRF
69c65
<    character(len=120), dimension(7), intent(in)  :: filesfcprefixes
---
>    character(len=120), dimension(7), intent(in) :: filesfcprefixes
84c80
<                         workprsi,qworkvar3d,wworkvar3d,workvar3d_tmp
---
>                         workprsi,qworkvar3d,workvar3d_tmp
90c86
<     logical           :: if_file_exist 
---
>      
99,100c95
<     integer :: w_ind, ql_ind, qi_ind, qr_ind, qs_ind, qg_ind, qnr_ind
<     integer :: dbz_ind
---
>     integer :: w_ind, ql_ind,qr_ind,qi_ind,qs_ind,qg_ind,dbz_ind
106,107c101
<     write (6,*)"The input fileprefix, reducedgrid are not used in the current implementation", &
<            fileprefixes, reducedgrid
---
>     write (6,*)"The input fileprefix, reducedgrid are not used in the current implementation"
111d104
<     w_ind   = getindex(vars3d, 'w')   ! W (3D)
117,125c110,116
< 
<     ql_ind  = getindex(vars3d, 'ql')   ! Q cloud water (3D)
<     qi_ind  = getindex(vars3d, 'qi')   ! Q cloud ice (3D)
<     qr_ind  = getindex(vars3d, 'qr')   ! Q rain water (3D)
<     qs_ind  = getindex(vars3d, 'qs')   ! Q snow (3D)
<     qg_ind  = getindex(vars3d, 'qg')   ! Q graupel (3D)
<     qnr_ind  = getindex(vars3d, 'qnr') ! N rain (3D)    
< 
<     dbz_ind  = getindex(vars3d, 'dbz')   ! Reflectivity (3D)
---
>     w_ind   = getindex(vars3d, 'w')   ! W (3D)
>     ql_ind   = getindex(vars3d, 'ql')   ! QL (3D)
>     qr_ind   = getindex(vars3d, 'qr')   ! QR (3D)
>     qi_ind   = getindex(vars3d, 'qi')   ! QI (3D)
>     qs_ind   = getindex(vars3d, 'qs')   ! QS (3D)
>     qg_ind   = getindex(vars3d, 'qg')   ! QG (3D)
>     dbz_ind   = getindex(vars3d, 'dbz')   ! DBZ (3D)
158,165c149,151
<       fv3filename=trim(adjustl(filename))//"_dynvartracer"
< 
<       inquire(file=fv3filename, exist=if_file_exist)
<       if ( .not. if_file_exist )then
<          fv3filename=trim(adjustl(filename))//"_dynvar"
<          fv3filename_tracer=trim(adjustl(filename))//"_tracer"
<          if(dbz_ind > 0) fv3filename_phyvar=trim(adjustl(filename))//"_phyvar"
<       end if
---
>       fv3filename=trim(adjustl(filename))//"_dynvar"
>       fv3filename_tracer=trim(adjustl(filename))//"_tracer"
>       fv3filename_phyvar=trim(adjustl(filename))//"_phyvar"
172,178c158,165
<       if ( .not. if_file_exist )then
<         call nc_check( nf90_open(trim(adjustl(fv3filename_tracer)),nf90_nowrite,file_id_t),&
<                        myname_,'open: '//trim(adjustl(fv3filename_tracer)) )
<   
<         call nc_check( nf90_open(trim(adjustl(fv3filename_phyvar)),nf90_nowrite,file_id_p),&
<                        myname_,'open: '//trim(adjustl(fv3filename_phyvar)) )
<       end if
---
>       call nc_check( nf90_open(trim(adjustl(fv3filename_tracer)),nf90_nowrite,file_id_t),&
>                     myname_,'open: '//trim(adjustl(fv3filename_tracer)) )
> 
>       call nc_check( nf90_open(trim(adjustl(fv3filename_phyvar)),nf90_nowrite,file_id_p),&
>                     myname_,'open: '//trim(adjustl(fv3filename_phyvar)) )
> 
> 
> 
224a212
> 
226d213
<     allocate(wworkvar3d(nx_res,ny_res,nlevs))
228c215
<        call read_fv3_restart_data3d(varstrname,fv3filename,file_id,wworkvar3d)
---
>        call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
234c221
<             vargrid(nn,levels(w_ind-1)+k,nb,ne)=wworkvar3d(i,j,k)
---
>             vargrid(nn,levels(w_ind-1)+k,nb,ne)=workvar3d(i,j,k)
243d229
<     deallocate(wworkvar3d)
247,260c233,235
<     if (tv_ind > 0.or.tsen_ind) then
<        allocate(tsenworkvar3d(nx_res,ny_res,nlevs))
<        varstrname = 'T'
<        call read_fv3_restart_data3d(varstrname,fv3filename,file_id,tsenworkvar3d)
<        varstrname = 'sphum'
<        if ( .not. if_file_exist )then
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,qworkvar3d)
<        else
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id,qworkvar3d)
<        end if
< 
< 
<        if (q_ind > 0) then
<            varstrname = 'sphum'
---
>     if (q_ind > 0) then
>         varstrname = 'sphum'
>         call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,qworkvar3d)
266c241
<                     vargrid(nn,levels(q_ind-1)+k,nb,ne)=qworkvar3d(i,j,k) 
---
>                     vargrid(nn,levels(q_ind-1)+k,nb,ne)=qworkvar3d(i,j,k)
271,272c246,247
<                  if (nproc .eq. 0)                                               &
<                     write(6,*) 'READFVregional : q ',                           &
---
>                  if (nproc .eq. 0) &
>                     write(6,*) 'READFVregional : q ', &
276,277c251,261
<         endif
<         if(tv_ind > 0) then
---
>     endif
>         
> 
>     if (tv_ind > 0.or.tsen_ind>0) then
>        allocate(tsenworkvar3d(nx_res,ny_res,nlevs))
>        varstrname = 'T'
>        call read_fv3_restart_data3d(varstrname,fv3filename,file_id,tsenworkvar3d)
>            if(.not.  (q_ind > 0)) then
>              varstrname = 'sphum'
>              call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,qworkvar3d)
>            endif
286c270
<         else! tsen_id >0
---
>         if(tsen_ind > 0) then
306,307c290,291
<         endif
<    if(allocated(tsenworkvar3d)) deallocate(tsenworkvar3d)
---
>       if(allocated(tsenworkvar3d)) deallocate(tsenworkvar3d)
>      endif
313,317c297
<        if ( .not. if_file_exist )then
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<        else
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<        end if
---
>        call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
335c315
<    if (ql_ind > 0) then
---
>     if (ql_ind > 0) then
337,344c317,320
<        if ( .not. if_file_exist )then
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<        else
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<        end if
<       do k=1,nlevs
<           nn = nn_tile0
<         do j=1,ny_res
---
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
>     do k=1,nlevs
>        nn = nn_tile0
>        do j=1,ny_res
349,352c325,328
<         enddo
<       enddo
<       do k = levels(ql_ind-1)+1, levels(ql_ind)
<           if (nproc .eq. 0)                                               &
---
>        enddo
>     enddo
>     do k = levels(ql_ind-1)+1, levels(ql_ind)
>         if (nproc .eq. 0)                                               &
355c331
<        enddo
---
>     enddo
359,368c335,340
<    if (qi_ind > 0) then
<        varstrname = 'ice_wat'
<        if ( .not. if_file_exist )then
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<        else
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<        end if
<       do k=1,nlevs
<           nn = nn_tile0
<         do j=1,ny_res
---
>     if (qr_ind > 0) then
>        varstrname = 'rainwat'
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
>     do k=1,nlevs
>        nn = nn_tile0
>        do j=1,ny_res
371c343
<             vargrid(nn,levels(qi_ind-1)+k,nb,ne)=workvar3d(i,j,k)
---
>             vargrid(nn,levels(qr_ind-1)+k,nb,ne)=workvar3d(i,j,k)
373,378d344
<         enddo
<       enddo
<       do k = levels(qi_ind-1)+1, levels(qi_ind)
<           if (nproc .eq. 0)                                               &
<              write(6,*) 'READFVregional : qi ',                           &
<                  & k, minval(vargrid(:,k,nb,ne)), maxval(vargrid(:,k,nb,ne))
379a346,351
>     enddo
>     do k = levels(qr_ind-1)+1, levels(qr_ind)
>         if (nproc .eq. 0)                                               &
>              write(6,*) 'READFVregional : qr ',                           &
>                  & k, minval(vargrid(:,k,nb,ne)), maxval(vargrid(:,k,nb,ne))
>     enddo
382,392c354,360
< 
<    if (qr_ind > 0) then
<        varstrname = 'rainwat'
<        if ( .not. if_file_exist )then
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<        else
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<        end if
<       do k=1,nlevs
<           nn = nn_tile0
<         do j=1,ny_res
---
>    
>     if (qi_ind > 0) then
>        varstrname = 'ice_wat'
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
>     do k=1,nlevs
>        nn = nn_tile0
>        do j=1,ny_res
395c363
<             vargrid(nn,levels(qr_ind-1)+k,nb,ne)=workvar3d(i,j,k)
---
>             vargrid(nn,levels(qi_ind-1)+k,nb,ne)=workvar3d(i,j,k)
397,402d364
<         enddo
<       enddo
<       do k = levels(qr_ind-1)+1, levels(qr_ind)
<           if (nproc .eq. 0)                                               &
<              write(6,*) 'READFVregional : qr ',                           &
<                  & k, minval(vargrid(:,k,nb,ne)), maxval(vargrid(:,k,nb,ne))
403a366,371
>     enddo
>     do k = levels(qi_ind-1)+1, levels(qi_ind)
>         if (nproc .eq. 0)                                               &
>              write(6,*) 'READFVregional : qi ',                           &
>                  & k, minval(vargrid(:,k,nb,ne)), maxval(vargrid(:,k,nb,ne))
>     enddo
407c375
<    if (qs_ind > 0) then
---
>     if (qs_ind > 0) then
409,416c377,380
<        if ( .not. if_file_exist )then
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<        else
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<        end if
<       do k=1,nlevs
<           nn = nn_tile0
<         do j=1,ny_res
---
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
>     do k=1,nlevs
>        nn = nn_tile0
>        do j=1,ny_res
421,424c385,388
<         enddo
<       enddo
<       do k = levels(qs_ind-1)+1, levels(qs_ind)
<           if (nproc .eq. 0)                                               &
---
>        enddo
>     enddo
>     do k = levels(qs_ind-1)+1, levels(qs_ind)
>         if (nproc .eq. 0)                                               &
427c391
<        enddo
---
>     enddo
431c395
<    if (qg_ind > 0) then
---
>     if (qg_ind > 0) then
433,440c397,400
<        if ( .not. if_file_exist )then
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<        else
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<        end if
<       do k=1,nlevs
<           nn = nn_tile0
<         do j=1,ny_res
---
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
>     do k=1,nlevs
>        nn = nn_tile0
>        do j=1,ny_res
445,450d404
<         enddo
<       enddo
<       do k = levels(qg_ind-1)+1, levels(qg_ind)
<           if (nproc .eq. 0)                                               &
<              write(6,*) 'READFVregional : qg ',                           &
<                  & k, minval(vargrid(:,k,nb,ne)), maxval(vargrid(:,k,nb,ne))
452,473c406,409
< 
<     endif
< 
<    if (qnr_ind > 0) then
<        varstrname = 'rain_nc'
<        if ( .not. if_file_exist )then
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<        else
<          call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<        end if
<       do k=1,nlevs
<           nn = nn_tile0
<         do j=1,ny_res
<          do i=1,nx_res
<             nn=nn+1
<             vargrid(nn,levels(qnr_ind-1)+k,nb,ne)=workvar3d(i,j,k)
<          enddo
<         enddo
<       enddo
<       do k = levels(qnr_ind-1)+1, levels(qnr_ind)
<           if (nproc .eq. 0)                                               &
<              write(6,*) 'READFVregional : qnr ',                           &
---
>     enddo
>     do k = levels(qg_ind-1)+1, levels(qg_ind)
>         if (nproc .eq. 0)                                               &
>              write(6,*) 'READFVregional : qg ',                           &
475c411
<        enddo
---
>     enddo
480c416
<        allocate(workvar3d_tmp(nx_res-6,ny_res-6,nlevs))
---
>     allocate(workvar3d_tmp(nx_res-6,ny_res-6,nlevs))
489,495c425,430
<        do k=1,nlevs
<          nn = nn_tile0
<          do j=1,ny_res
<            do i=1,nx_res
<               nn=nn+1
<               vargrid(nn,levels(dbz_ind-1)+k,nb,ne)=workvar3d(i,j,nlevs+1-k)
<            enddo
---
>     do k=1,nlevs
>        nn = nn_tile0
>        do j=1,ny_res
>          do i=1,nx_res
>             nn=nn+1
>             vargrid(nn,levels(dbz_ind-1)+k,nb,ne)=workvar3d(i,j,nlevs+1-k)
498,500c433,436
<        do k = levels(dbz_ind-1)+1, levels(dbz_ind)
<          if (nproc .eq. 0)                                               &
<                  write(6,*) 'READFVregional : dbz ',                           &
---
>     enddo
>     do k = levels(dbz_ind-1)+1, levels(dbz_ind)
>         if (nproc .eq. 0)                                               &
>              write(6,*) 'READFVregional : dbz ',                           &
502c438
<        enddo
---
>     enddo
505c441
<    
---
> 
509,511c445,449
<     if( .not. if_file_exist )then
<       call nc_check( nf90_close(file_id_t),&
<            myname_,'close '//trim(fv3filename_tracer) )
---
>     call nc_check( nf90_close(file_id_t),&
>          myname_,'close '//trim(fv3filename_tracer) )
> 
>     call nc_check( nf90_close(file_id_p),&
>          myname_,'close '//trim(fv3filename_phyvar) )
513,515d450
<       call nc_check( nf90_close(file_id_p),&
<            myname_,'close '//trim(fv3filename_phyvar) )
<     end if
528,532c463
<       fv3filename=trim(adjustl(filename))//"_dynvartracer"
<       inquire(file=fv3filename, exist=if_file_exist)
<       if ( .not. if_file_exist )then
<          fv3filename=trim(adjustl(filename))//"_dynvar"
<       end if
---
>       fv3filename=trim(adjustl(filename))//"_dynvar"
582d512
<       enddo
583a514
>       enddo
607c538
<   ! readgriddata_nmm.f90: read FV3-Lam state or control vector
---
>   ! readgriddata_nmm.f90: read WRF-NMM state or control vector
612c543
<   ! writegriddata.f90: write FV3-LAM analysis
---
>   ! writegriddata.f90: write WRF-ARW or WRF-NMM analysis
641d571
<     logical             :: if_file_exist
645,647c575
<     integer(i_kind) :: w_ind, cw_ind, ph_ind
<     integer(i_kind) :: ql_ind, qi_ind, qr_ind, qs_ind, qg_ind, qnr_ind
<     integer(i_kind) :: dbz_ind
---
>     integer(i_kind) :: w_ind, ql_ind,qr_ind,qi_ind,qs_ind,qg_ind,dbz_ind
650c578
<     real(r_single), dimension(:,:), allocatable ::pswork
---
>       real(r_single), dimension(:,:), allocatable ::pswork
653,655c581
<                         workprsi,qworkvar3d,wworkvar3d,workvar3d_tmp
< 
<     real(r_single)              :: clip
---
>                         workprsi,qworkvar3d,qbgworkvar3d,workvar3d_tmp
672,673c598
<     write(6,*)"anlfileprefixes, fgfileprefixes are not used in the current implementation", &
<                anlfileprefixes, fgfileprefixes  
---
>     write(6,*)"anlfileprefixes, fgfileprefixes are not used in the current implementation"
683,686d607
<     cw_ind  = getindex(vars3d, 'cw')  ! CWM for WRF-NMM
<     oz_ind  = getindex(vars3d, 'oz')  ! Oz (3D)
<     w_ind   = getindex(vars3d, 'w')   ! W for WRF-ARW
<     ph_ind  = getindex(vars3d, 'ph')  ! PH for WRF-ARW
688,693c609,615
<     ql_ind  = getindex(vars3d, 'ql')  ! QL (3D) for FV3
<     qi_ind  = getindex(vars3d, 'qi')  ! QI (3D) for FV3
<     qr_ind  = getindex(vars3d, 'qr')  ! QR (3D) for FV3
<     qs_ind  = getindex(vars3d, 'qs')  ! QS (3D) for FV3
<     qg_ind  = getindex(vars3d, 'qg')  ! QG (3D) for FV3
<     qnr_ind  = getindex(vars3d, 'qnr')  ! QNR (3D) for FV3
---
>     w_ind   = getindex(vars3d, 'w')   ! W (3D)
>     ql_ind   = getindex(vars3d, 'ql')   ! QL (3D)
>     qr_ind   = getindex(vars3d, 'qr')   ! QR (3D)
>     qi_ind   = getindex(vars3d, 'qi')   ! QI (3D)
>     qs_ind   = getindex(vars3d, 'qs')   ! QS (3D)
>     qg_ind   = getindex(vars3d, 'qg')   ! QG (3D)
>     dbz_ind   = getindex(vars3d, 'dbz')   ! DBZ (3D)
695,696d616
<     dbz_ind  = getindex(vars3d, 'dbz')  ! Reflectivity (3D)
<     
712a633
>     allocate(qbgworkvar3d(nx_res,ny_res,nlevs))
728,735c649
<       fv3filename=trim(adjustl(filename))//"_dynvartracer"
< 
<       inquire(file=fv3filename, exist=if_file_exist)
<       if ( .not. if_file_exist )then
<          fv3filename=trim(adjustl(filename))//"_dynvar"
<          fv3filename_tracer=trim(adjustl(filename))//"_tracer"
<          if(dbz_ind > 0) fv3filename_phyvar=trim(adjustl(filename))//"_phyvar"
<       end if
---
>       fv3filename=trim(adjustl(filename))//"_dynvar"
736a651,652
>       fv3filename_tracer=trim(adjustl(filename))//"_tracer"
>       fv3filename_phyvar=trim(adjustl(filename))//"_phyvar"
740,741c656,660
<       call nc_check( nf90_open(trim(adjustl(fv3filename)),nf90_write,file_id),&
<         myname_,'open: '//trim(adjustl(fv3filename)) )
---
>       call nc_check( nf90_open(trim(adjustl(fv3filename)),NF_WRITE,file_id),&
>                     myname_,'open: '//trim(adjustl(fv3filename)) )
> 
>       call nc_check( nf90_open(trim(adjustl(fv3filename_tracer)),nf_write,file_id_t),&
>                     myname_,'open: '//trim(adjustl(fv3filename_tracer)) )
743,748c662,663
<       if ( .not. if_file_exist )then
<          call nc_check( nf90_open(trim(adjustl(fv3filename_tracer)),nf_write,file_id_t),&
<                         myname_,'open: '//trim(adjustl(fv3filename_tracer)) )
<          call nc_check( nf90_open(trim(adjustl(fv3filename_phyvar)),nf_write,file_id_p),&
<                         myname_,'open: '//trim(adjustl(fv3filename_phyvar)) )
<       end if
---
>       call nc_check( nf90_open(trim(adjustl(fv3filename_phyvar)),nf_write,file_id_p),&
>                     myname_,'open: '//trim(adjustl(fv3filename_phyvar)) )
796d710
<        allocate(wworkvar3d(nx_res,ny_res,nlevs))
798c712
<        call read_fv3_restart_data3d(varstrname,fv3filename,file_id,wworkvar3d)
---
>        call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
808,810c722,724
<       wworkvar3d(1:nx_res,:,:)=wworkvar3d(1:nx_res,:,:)+workinc3d
<       wworkvar3d(nx_res+1,:,:)=wworkvar3d(nx_res,:,:)
<        call write_fv3_restart_data3d(varstrname,fv3filename,file_id,wworkvar3d)
---
>       workvar3d(1:nx_res,:,:)=workvar3d(1:nx_res,:,:)+workinc3d
>       workvar3d(nx_res+1,:,:)=workvar3d(nx_res,:,:)
>        call write_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
812d725
<        deallocate(wworkvar3d)
814a728,754
>      if(q_ind>0) then
> 
>        varstrname='sphum'
>         call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,qbgworkvar3d)
>           do k=1,nlevs
>               nn = nn_tile0
>           do j=1,ny_res
>              do i=1,nx_res
>                 nn=nn+1
>                 workinc3d(i,j,k)=vargrid(nn,levels(q_ind-1)+k,nb,ne)
>              enddo
>           enddo
>           enddo
>           qworkvar3d=qbgworkvar3d +workinc3d
>           where( qworkvar3d < 0.0_r_kind )
>              qworkvar3d = 0.0_r_kind
>           end where
>  
>        workvar3d = qworkvar3d
>        call write_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
>        do k=1,nlevs
>           if (nproc .eq. 0)                                               &
>              write(6,*) 'WRITEregional : sphum ',                           &
>                  & k, minval(workvar3d(:,:,k)), maxval(workvar3d(:,:,k))
>        enddo
>     end if
> 
845,850c785,788
<        varstrname = 'sphum'
<         if ( .not. if_file_exist )then
<           call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,qworkvar3d)
<         else
<           call read_fv3_restart_data3d(varstrname,fv3filename,file_id,qworkvar3d)
<         end if
---
>        if( .not. (q_ind > 0) )then
>          varstrname = 'sphum'
>          call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,qworkvar3d)
>        end if
853,864c791,795
<        if(q_ind > 0) then
<       do k=1,nlevs
<           nn = nn_tile0
<       do j=1,ny_res
<          do i=1,nx_res
<             nn=nn+1
<             workinc3d(i,j,k)=vargrid(nn,levels(q_ind-1)+k,nb,ne) 
<          enddo
<       enddo
<       enddo
<        qworkvar3d=qworkvar3d+workinc3d   
<        endif
---
>       if(.not. ( q_ind > 0)) then
>        tsenworkvar3d=tvworkvar3d/(one+fv*qbgworkvar3d)
>       else
>        tsenworkvar3d=tvworkvar3d/(one+fv*qworkvar3d)
>       endif
874,893d804
< 
< 
< 
<        if(q_ind>0) then
<        varstrname='sphum'
<      
<         if ( .not. if_file_exist )then
<            call write_fv3_restart_data3d(varstrname,fv3filename,file_id_t,qworkvar3d)
<         else
<            call write_fv3_restart_data3d(varstrname,fv3filename,file_id,qworkvar3d)
<         end if
<        do k=1,nlevs
<           if (nproc .eq. 0)                                               &
<              write(6,*) 'WRITEregional : sphum ',                           &
<                  & k, minval(qworkvar3d(:,:,k)), maxval(qworkvar3d(:,:,k))
<        enddo
<        endif
<        
<       
<        
895c806
<      endif
---
>      endif  !if tsens else tv
897a809,810
> 
> 
901,905c814
<       if ( .not. if_file_exist )then
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
---
>        call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
916,920c825
<       if ( .not. if_file_exist )then
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
---
>        call write_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
926,930d830
<       if ( .not. if_file_exist )then
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
931a832
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
941,950c842,846
<       workvar3d=workvar3d+workinc3d
<        if ( cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(workvar3d(1,1,1))
<            where (workvar3d < clip) workvar3d = clip
<        end if
<       if ( .not. if_file_exist )then
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
---
>       workvar3d(1:nx_res,:,:)=workvar3d(1:nx_res,:,:)+workinc3d
>       where( workvar3d < 0.0_r_kind )
>            workvar3d = 0.0_r_kind
>       end where
>        call write_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
954,961c850,853
<     if (qi_ind > 0) then
<        varstrname = 'ice_wat'
< 
<       if ( .not. if_file_exist )then
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
---
>     if (qr_ind > 0) then
>        varstrname = 'rainwat'
>        
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
967c859
<             workinc3d(i,j,k)=vargrid(nn,levels(qi_ind-1)+k,nb,ne)
---
>             workinc3d(i,j,k)=vargrid(nn,levels(qr_ind-1)+k,nb,ne)
971,981c863,868
<       workvar3d=workvar3d+workinc3d
<        if ( cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(workvar3d(1,1,1))
<            where (workvar3d < clip) workvar3d = clip
<        end if
<       if ( .not. if_file_exist )then
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
< 
---
>       workvar3d(1:nx_res,:,:)=workvar3d(1:nx_res,:,:)+workinc3d
>       where( workvar3d < 0.0_r_kind )
>            workvar3d = 0.0_r_kind
>       end where
>        call write_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
>          
984,985c871,872
<     if (qr_ind > 0) then
<        varstrname = 'rainwat'
---
>     if (qi_ind > 0) then
>        varstrname = 'ice_wat'
987,991c874
<       if ( .not. if_file_exist )then
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
---
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
997c880
<             workinc3d(i,j,k)=vargrid(nn,levels(qr_ind-1)+k,nb,ne)
---
>             workinc3d(i,j,k)=vargrid(nn,levels(qi_ind-1)+k,nb,ne)
1001,1010c884,888
<       workvar3d=workvar3d+workinc3d
<        if ( cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(workvar3d(1,1,1))
<            where (workvar3d < clip) workvar3d = clip
<        end if
<       if ( .not. if_file_exist )then
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
---
>       workvar3d(1:nx_res,:,:)=workvar3d(1:nx_res,:,:)+workinc3d
>       where( workvar3d < 0.0_r_kind )
>            workvar3d = 0.0_r_kind
>       end where
>        call write_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
1017,1021c895
<       if ( .not. if_file_exist )then
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
---
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
1031,1040c905,909
<       workvar3d=workvar3d+workinc3d
<        if ( cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(workvar3d(1,1,1))
<            where (workvar3d < clip) workvar3d = clip
<        end if
<       if ( .not. if_file_exist )then
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
---
>       workvar3d(1:nx_res,:,:)=workvar3d(1:nx_res,:,:)+workinc3d
>       where( workvar3d < 0.0_r_kind )
>            workvar3d = 0.0_r_kind
>       end where
>        call write_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
1046,1051c915,916
<  
<       if ( .not. if_file_exist )then
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
---
> 
>        call read_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
1061,1072c926,930
<       workvar3d=workvar3d+workinc3d
<        if ( cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(workvar3d(1,1,1))
<            where (workvar3d < clip) workvar3d = clip
<        end if
<       if ( .not. if_file_exist )then
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
< 
<     endif
---
>       workvar3d(1:nx_res,:,:)=workvar3d(1:nx_res,:,:)+workinc3d
>       where( workvar3d < 0.0_r_kind )
>            workvar3d = 0.0_r_kind
>       end where
>        call write_fv3_restart_data3d(varstrname,fv3filename_tracer,file_id_t,workvar3d)
1074,1100d931
<     if (qnr_ind > 0) then
<        varstrname = 'rain_nc'
< 
<       if ( .not. if_file_exist )then
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<         call read_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
<       do k=1,nlevs
<           nn = nn_tile0
<          do j=1,ny_res
<           do i=1,nx_res
<             nn=nn+1
<             workinc3d(i,j,k)=vargrid(nn,levels(qnr_ind-1)+k,nb,ne)
<           enddo
<          enddo
<       enddo
<       workvar3d=workvar3d+workinc3d
<        if ( cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(workvar3d(1,1,1))
<            where (workvar3d < clip) workvar3d = clip
<        end if
<       if ( .not. if_file_exist )then
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id_t,workvar3d)
<       else
<          call write_fv3_restart_data3d(varstrname,fv3filename,file_id,workvar3d)
<       end if
1113,1119c944,949
<        do k=1,nlevs
<          nn = nn_tile0
<          do j=1,ny_res
<            do i=1,nx_res
<              nn=nn+1
<              workinc3d(i,j,nlevs+1-k)=vargrid(nn,levels(dbz_ind-1)+k,nb,ne)
<            enddo
---
>       do k=1,nlevs
>           nn = nn_tile0
>       do j=1,ny_res
>          do i=1,nx_res
>             nn=nn+1
>             workinc3d(i,j,nlevs+1-k)=vargrid(nn,levels(dbz_ind-1)+k,nb,ne)
1121,1124c951,955
<        enddo
<        workvar3d(1:nx_res,:,:)=workvar3d(1:nx_res,:,:)+workinc3d
<        workvar3d_tmp = workvar3d(4:nx_res-3,4:ny_res-3,1:nlevs)
<        where( workvar3d_tmp < 0.0_r_kind )
---
>       enddo
>       enddo
>       workvar3d(1:nx_res,:,:)=workvar3d(1:nx_res,:,:)+workinc3d
>       workvar3d_tmp = workvar3d(4:nx_res-3,4:ny_res-3,1:nlevs)
>       where( workvar3d_tmp < 0.0_r_kind )
1126c957
<        end where
---
>       end where
1130d960
< 
1133,1137c963,967
<     if (ps_ind > 0) then
<       allocate(workprsi(nx_res,ny_res,nlevsp1))
<       allocate(pswork(nx_res,ny_res))
<       varstrname = 'delp'
<       call read_fv3_restart_data3d(varstrname,filename,file_id,workvar3d)   ! Pascal
---
>       if (ps_ind > 0) then
>        allocate(workprsi(nx_res,ny_res,nlevsp1))
>        allocate(pswork(nx_res,ny_res))
>        varstrname = 'delp'
>       call read_fv3_restart_data3d(varstrname,filename,file_id,workvar3d)  
1142c972
<       enddo
---
>        enddo
1144c974,976
<       nn = nn_tile0
---
> 
> 
>           nn = nn_tile0
1163c995
<           workprsi(:,:,k)=eta1_ll(k)+eta2_ll(k)*workprsi(:,:,1)
---
>         workprsi(:,:,k)=eta1_ll(k)+eta2_ll(k)*workprsi(:,:,1)
1167c999
<          workvar3d(:,:,k)=(workprsi(:,:,k)-workprsi(:,:,k+1))*100.0
---
>         workvar3d(:,:,k)=(workprsi(:,:,k)-workprsi(:,:,k+1))*100.0
1169c1001
< 
---
>         
1172c1004
<     end if
---
>      endif
1175c1007
<       myname_,'close '//trim(filename) )
---
>       myname_,'close '//trim(fv3filename) )
1177,1179c1009,1010
<     if ( .not. if_file_exist )then
<       call nc_check( nf90_close(file_id_t),&
<         myname_,'close '//trim(fv3filename_tracer) )
---
>     call nc_check( nf90_close(file_id_t),&
>       myname_,'close '//trim(fv3filename_tracer) )
1181,1183c1012,1013
<       call nc_check( nf90_close(file_id_p),&
<         myname_,'close '//trim(fv3filename_phyvar) )
<     end if
---
>     call nc_check( nf90_close(file_id_p),&
>       myname_,'close '//trim(fv3filename_phyvar) )
1201a1032
>    if(allocated(workvar3d)) deallocate(workvar3d)
1209,1212c1040,1042
<   subroutine writeincrement(nanal1,nanal2,vars3d,vars2d,n3d,n2d,levels,ndim,grdin,no_inflate_flag)
<  !Dummy subroutine declaration in place of  the actual subroutine definition in
<  !the GFS EnKF
<  !to be implemented in the future
---
> 
>   subroutine readgriddata_pnc(vars3d,vars2d,n3d,n2d,levels,ndim,ntimes, &
>                                fileprefixes,filesfcprefixes,reducedgrid,grdin,qsat)
1214d1043
<     use params, only: nbackgrounds
1216d1044
<     integer, intent(in) :: nanal1,nanal2
1219c1047
<     integer, intent(in) :: n2d,n3d,ndim
---
>     integer, intent(in) :: n2d, n3d
1221,1223c1049,1055
<     real(r_single), dimension(npts,ndim,nbackgrounds,1), intent(inout) :: grdin
<     logical, intent(in) :: no_inflate_flag
<   end subroutine writeincrement
---
>     integer, intent(in) :: ndim, ntimes
>     character(len=120), dimension(7), intent(in)  :: fileprefixes
>     character(len=120), dimension(7), intent(in)  :: filesfcprefixes
>     logical, intent(in) :: reducedgrid
>     real(r_single), dimension(npts,ndim,ntimes,1), intent(out) :: grdin
>     real(r_double), dimension(npts,nlevs,ntimes,1), intent(out) :: qsat
>   end subroutine readgriddata_pnc
1225,1228c1057
<   subroutine writeincrement_pnc(vars3d,vars2d,n3d,n2d,levels,ndim,grdin,no_inflate_flag)
<  !Dummy subroutine declaration in place of  the actual subroutine definition in
<  !the GFS EnKF
<  !to be implemented in the future
---
>   subroutine writegriddata_pnc(vars3d,vars2d,n3d,n2d,levels,ndim,grdin,no_inflate_flag)
1238,1244c1067,1069
<   end subroutine writeincrement_pnc
<   
<   subroutine readgriddata_pnc(vars3d,vars2d,n3d,n2d,levels,ndim,ntimes, &
<                                fileprefixes,filesfcprefixes,reducedgrid,grdin,qsat)
<  !Dummy subroutine declaration in place of  the actual subroutine definition in
<  !the GFS EnKF
<  !to be implemented in the future
---
>   end subroutine writegriddata_pnc
> 
>   subroutine writeincrement(nanal1,nanal2,vars3d,vars2d,n3d,n2d,levels,ndim,grdin,no_inflate_flag)
1245a1071
>     use params, only: nbackgrounds
1246a1073
>     integer, intent(in) :: nanal1,nanal2
1249c1076
<     integer, intent(in) :: n2d, n3d
---
>     integer, intent(in) :: n2d,n3d,ndim
1251,1257c1078,1080
<     integer, intent(in) :: ndim, ntimes
<     character(len=120), dimension(7), intent(in)  :: fileprefixes
<     character(len=120), dimension(7), intent(in)  :: filesfcprefixes
<     logical, intent(in) :: reducedgrid
<     real(r_single), dimension(npts,ndim,ntimes,1), intent(out) :: grdin
<     real(r_double), dimension(npts,nlevs,ntimes,1), intent(out) :: qsat
<   end subroutine readgriddata_pnc
---
>     real(r_single), dimension(npts,ndim,nbackgrounds,1), intent(inout) :: grdin
>     logical, intent(in) :: no_inflate_flag
>   end subroutine writeincrement
1259,1262c1082
<   subroutine writegriddata_pnc(vars3d,vars2d,n3d,n2d,levels,ndim,grdin,no_inflate_flag)
<  !Dummy subroutine declaration in place of  the actual subroutine definition in
<  !the GFS EnKF
<  !to be implemented in the future
---
>   subroutine writeincrement_pnc(vars3d,vars2d,n3d,n2d,levels,ndim,grdin,no_inflate_flag)
1272,1273c1092
<   end subroutine writegriddata_pnc
< 
---
>   end subroutine writeincrement_pnc
gridio_gfs.f90
167d166
<   clip = tiny(vg(1))
210d208
<      ! k=1 in ak,bk is model top
336,345c334,335
<         ! pressure at bottom of layer interface (for gps jacobian, see prsltmp in setupbend.f90)
<         if (prse_ind > 0) then
<            ug(:) = pressi(:,k)
<            call copytogrdin(ug,pslg(:,k))
<            ! Jacobian for gps in pressure is saved in different units in GSI; need to
<            ! multiply pressure by 0.1
<            grdin(:,levels(prse_ind-1)+k,nb,ne) = 0.1*pslg(:,k)
<         endif
<         ! layer pressure from phillips vertical interolation (used for qsat
<         ! calculation)
---
>         krev = nlevs-k+1
>         ! layer pressure from phillips vertical interolation
348a339,341
>         ! Jacobian for gps in pressure is saved in different units in GSI; need to
>         ! multiply pressure by 0.1
>         if (prse_ind > 0)     grdin(:,levels(prse_ind-1)+k,nb,ne) = 0.1*pslg(:,k)
633d625
<         ! k=1 in ak,bk is model top
960,969c952
<     ! pressure at bottom of layer interface (for gps jacobian, see prsltmp in setupbend.f90)
<     if (prse_ind > 0) then
<        ug(:) = pressi(:,k)
<        call copytogrdin(ug,pslg(:,k))
<        ! Jacobian for gps in pressure is saved in different units in GSI; need to
<        ! multiply pressure by 0.1
<        grdin(:,levels(prse_ind-1)+k,nb,ne) = 0.1*pslg(:,k)
<     endif
<     ! layer pressure from phillips vertical interolation (used for qsat
<     ! calculation)
---
>     ! layer pressure from phillips vertical interolation
971a955
> 
972a957,960
>     ! Jacobian for gps in pressure is saved in different units in GSI; need to
>     ! multiply pressure by 0.1
>     if (prse_ind > 0)     grdin(:,levels(prse_ind-1)+k,nb,ne) = 0.1*pslg(:,k)
> 
1127,1129c1115
<   do nb=1,nbackgrounds
<      call mpi_bcast(grdin(1,1,nb,1),npts*ndim, mpi_real4, 0, iocomms(mem_pe(nproc)), iret)
<   enddo
---
>   call mpi_bcast(grdin,npts*ndim*nbackgrounds, mpi_real4, 0, iocomms(mem_pe(nproc)), iret)
1162d1147
<      ! k=1 in values_1d is model top, flip so k=1 in ak is bottom
1171d1155
<      ! k=1 in values_1d is model top, flip so k=1 in ak is bottom
1527c1511
<         krev = nlevs-k+1 ! k=1 is model top
---
>         krev = nlevs-k+1
1531,1533c1515
<         ! ug is hydrostatic analysis delz (should be negative)
<         ! (note that ak,bk are already reversed to go from bottom to top)
<         ug=ug*log((100_r_kind*ak(krev+1)+bk(krev+1)*vg)/(100_r_kind*ak(krev)+bk(krev)*vg))
---
>         ug=ug*log((100_r_kind*ak(krev)+bk(krev)*vg)/(100_r_kind*ak(krev+1)+bk(krev+1)*vg))
1535c1517
<         ! delzb is (negative) hydrostatic background delz inferred from background ps,Tv
---
>         ! delzb is hydrostatic background delz inferred from background ps,Tv
1537,1538c1519,1520
<         delzb=delzb*log((100_r_kind*ak(krev+1)+bk(krev+1)*values_1d)/(100_r_kind*ak(krev)+bk(krev)*values_1d))
<         ug3d(:,:,ki)=values_3d(:,:,ki) + reshape(ug-delzb,(/nlons,nlats/)) 
---
>         delzb=delzb*log((100_r_kind*ak(krev)+bk(krev)*values_1d)/(100_r_kind*ak(krev+1)+bk(krev+1)*values_1d))
>         ug3d(:,:,ki)=values_3d(:,:,ki) + reshape(delzb-ug,(/nlons,nlats/))
1852c1834
<                     nccompress,write_ensmean
---
>                     nccompress
1901c1883
<   integer k,krev,nt,ierr,iunitsig,nb,i,ne,nanal
---
>   integer k,nt,ierr,iunitsig,nb,i,ne,nanal
1920,1922c1902,1903
<   if (nanal == 0 .and. write_ensmean) then
<      filenamein = trim(adjustl(datapath))//trim(adjustl(fgfileprefixes(nb)))//"ensmean"
<      filenameout = trim(adjustl(datapath))//trim(adjustl(anlfileprefixes(nb)))//"ensmean"
---
>   if(no_inflate_flag) then
>     filenameout = trim(adjustl(datapath))//trim(adjustl(anlfileprefixes(nb)))//"nimem"//charnanal
1924,1930c1905,1907
<      if(no_inflate_flag) then
<        filenameout = trim(adjustl(datapath))//trim(adjustl(anlfileprefixes(nb)))//"nimem"//charnanal
<      else
<        filenameout = trim(adjustl(datapath))//trim(adjustl(anlfileprefixes(nb)))//"mem"//charnanal
<      end if
<      filenamein = trim(adjustl(datapath))//trim(adjustl(fgfileprefixes(nb)))//"mem"//charnanal
<   endif
---
>     filenameout = trim(adjustl(datapath))//trim(adjustl(anlfileprefixes(nb)))//"mem"//charnanal
>   end if
>   filenamein = trim(adjustl(datapath))//trim(adjustl(fgfileprefixes(nb)))//"mem"//charnanal
1994d1970
<         ! k=1 in values_1d is model top, flip so k=1 in ak is bottom
2003d1978
<         ! k=1 in values_1d is model top, flip so k=1 in ak is bottom
2502,2504c2477,2478
<            ! ps in Pa here, need to multiply ak by 100. k is bottom to top,
<            ! calculate delzb so it is negative.
<            delzb=delzb*log((100_r_kind*ak(k+1)+bk(k+1)*nems_wrk2)/(100_r_kind*ak(k)+bk(k)*nems_wrk2))
---
>            ! ps in Pa here, need to multiply ak by 100.
>            delzb=delzb*log((100_r_kind*ak(k)+bk(k)*nems_wrk2)/(100_r_kind*ak(k+1)+bk(k+1)*nems_wrk2))
2536,2538c2510,2511
<            ! k is bottom to top, calculate delz so it is negative
<            ug=ug*log((100_r_kind*ak(k+1)+bk(k+1)*vg)/(100_r_kind*ak(k)+bk(k)*vg))
<            ug=ug-delzb ! analysis - background
---
>            ug=ug*log((100_r_kind*ak(k)+bk(k)*vg)/(100_r_kind*ak(k+1)+bk(k+1)*vg))
>            ug=ug-delzb
2544,2545c2517
<            ! flip sign of delz increment if background is positive.
<            if (sum(nems_wrk) > 0.0_r_kind) ug = ug * -1.0_r_kind
---
>            if (sum(nems_wrk) < 0.0_r_kind) ug = ug * -1.0_r_kind
2906,2907c2878
<            krev = nlevs-k+1  ! k=1 is model top
<            ug=(rd/grav)*reshape(tv_anal(:,:,k),(/nlons*nlats/))
---
>            ug=(rd/grav)*reshape(tv_anal(:,:,nlevs-k+1),(/nlons*nlats/))
2909,2911c2880
<            ! ug is analysis delz, calculate so it is negative
<            ! (note that ak,bk are already reversed to go from bottom to top)
<            ug=ug*log((100_r_kind*ak(krev+1)+bk(krev+1)*vg)/(100_r_kind*ak(krev)+bk(krev)*vg))
---
>            ug=ug*log((100_r_kind*ak(k)+bk(k)*vg)/(100_r_kind*ak(k+1)+bk(k+1)*vg))
2914,2918c2883,2886
<            ! calculate so it is negative
<            delzb=(rd/grav)*reshape(tv_bg(:,:,k),(/nlons*nlats/))
<            delzb=delzb*log((100_r_kind*ak(krev+1)+bk(krev+1)*values_1d)/(100_r_kind*ak(krev)+bk(krev)*values_1d))
<            ug3d(:,:,k)=values_3d(:,:,k) +&
<            reshape(ug-delzb,(/nlons,nlats/))
---
>            delzb=(rd/grav)*reshape(tv_bg(:,:,nlevs-k+1),(/nlons*nlats/))
>            delzb=delzb*log((100_r_kind*ak(k)+bk(k)*values_1d)/(100_r_kind*ak(k+1)+bk(k+1)*values_1d))
>            ug3d(:,:,nlevs-k+1)=values_3d(:,:,nlevs-k+1) +&
>            reshape(delzb-ug,(/nlons,nlats/))
2919a2888
>         !print *,'min/max delz',minval(values_3d),maxval(values_3d),&
3308c3277
<                     datestring,nhr_anal,write_ensmean
---
>                     datestring,nhr_anal
3373,3375c3342,3343
<   if (nanal == 0 .and. write_ensmean) then
<      filenameout = trim(adjustl(datapath))//trim(adjustl(incfileprefixes(nb)))//"ensmean"
<      filenamein = trim(adjustl(datapath))//trim(adjustl(fgfileprefixes(nb)))//"ensmean"
---
>   if(no_inflate_flag) then
>     filenameout = trim(adjustl(datapath))//trim(adjustl(incfileprefixes(nb)))//"nimem"//charnanal
3377,3383c3345,3347
<      if(no_inflate_flag) then
<        filenameout = trim(adjustl(datapath))//trim(adjustl(incfileprefixes(nb)))//"nimem"//charnanal
<      else
<        filenameout = trim(adjustl(datapath))//trim(adjustl(incfileprefixes(nb)))//"mem"//charnanal
<      end if
<      filenamein = trim(adjustl(datapath))//trim(adjustl(fgfileprefixes(nb)))//"mem"//charnanal
<   endif
---
>     filenameout = trim(adjustl(datapath))//trim(adjustl(incfileprefixes(nb)))//"mem"//charnanal
>   end if
>   filenamein = trim(adjustl(datapath))//trim(adjustl(fgfileprefixes(nb)))//"mem"//charnanal
3447d3410
<      ! k=1 in values_1d is model top, flip so k=1 in ak is bottom
3456d3418
<      ! k=1 in values_1d is model top, flip so k=1 in ak is bottom
3611c3573
<         krev = nlevs-k+1 ! k=1 is model top
---
>         krev = nlevs-k+1
3614,3616c3576
<         ! calculate ug (analysis delz) so it is negative. 
<         ! (note that ak,bk are already reversed to go from bottom to top)
<         ug=ug*log((100_r_kind*ak(krev+1)+bk(krev+1)*vg)/(100_r_kind*ak(krev)+bk(krev)*vg))
---
>         ug=ug*log((100_r_kind*ak(krev)+bk(krev)*vg)/(100_r_kind*ak(krev+1)+bk(krev+1)*vg))
3620,3621c3580,3581
<         delzb=delzb*log((100_r_kind*ak(krev+1)+bk(krev+1)*psges)/(100_r_kind*ak(krev)+bk(krev)*psges))
<         inc3d(:,:,k)=reshape(ug-delzb,(/nlons,nlats/))
---
>         delzb=delzb*log((100_r_kind*ak(krev)+bk(krev)*psges)/(100_r_kind*ak(krev+1)+bk(krev+1)*psges))
>         inc3d(:,:,k)=reshape(delzb-ug,(/nlons,nlats/))
3797,3799c3757
<   do nb=1,nbackgrounds
<      call mpi_bcast(grdin(1,1,nb,1),npts*ndim, mpi_real4, 0, iocomms(mem_pe(nproc)), iret)
<   enddo
---
>   call mpi_bcast(grdin,npts*ndim*nbackgrounds, mpi_real4, 0, iocomms(mem_pe(nproc)), iret)
3885d3842
<      ! k=1 in values_1d is model top, flip so k=1 in ak is bottom
3894d3850
<      ! k=1 in values_1d is model top, flip so k=1 in ak is bottom
4062,4064c4018
<         ! calculate analysis delz so it is negative.
<         ! (note that ak,bk are already reversed to go from bottom to top)
<         ug=ug*log((100_r_kind*ak(krev+1)+bk(krev+1)*vg)/(100_r_kind*ak(krev)+bk(krev)*vg))
---
>         ug=ug*log((100_r_kind*ak(krev)+bk(krev)*vg)/(100_r_kind*ak(krev+1)+bk(krev+1)*vg))
4067d4020
<         ! calculate delzb so it is negative
4069,4070c4022,4023
<         delzb=delzb*log((100_r_kind*ak(krev+1)+bk(krev+1)*psges)/(100_r_kind*ak(krev)+bk(krev)*psges))
<         inc3d(:,:,ki)=reshape(ug-delzb,(/nlons,nlats/))
---
>         delzb=delzb*log((100_r_kind*ak(krev)+bk(krev)*psges)/(100_r_kind*ak(krev+1)+bk(krev+1)*psges))
>         inc3d(:,:,ki)=reshape(delzb-ug,(/nlons,nlats/))
gridio_nmmb.f90
gridio_wrf.f90
27,31d26
<   !   2021-02-08 CAPS(J. Park) 
<   !                   - add cliptracer to remove negative hydrometeors
<   !                     when updating analysis file.
<   !                   - add subroutine 'writewrfvar_native' to minimize
<   !                     interpolation error on wind analysis (A-C grid conversion)
45c40
<                       pseudo_rh, nmm_restart, l_use_enkf_directZDA
---
>                       pseudo_rh, nmm_restart
262c257
<     if ( qni_ind > 0 ) then
---
>     if ( qi_ind > 0 ) then
760,766c755,757
<        if ( l_use_enkf_directZDA ) then ! add wind increment at native grid to reduce interpolation error
<           call writewrfvar_native(filename, varstrname, vargrid(:,levels(u_ind-1)+1:levels(u_ind),nb,ne), nlevs)
<        else
<           call readwrfvar(filename, varstrname, enkf_field, nlevs)
<           enkf_field = enkf_field + vargrid(:,levels(u_ind-1)+1:levels(u_ind),nb,ne)
<           call writewrfvar(filename, varstrname, enkf_field, nlevs)   
<        end if
---
>        call readwrfvar(filename, varstrname, enkf_field, nlevs)
>        enkf_field = enkf_field + vargrid(:,levels(u_ind-1)+1:levels(u_ind),nb,ne)
>        call writewrfvar(filename, varstrname, enkf_field, nlevs)
770,776c761,763
<        if ( l_use_enkf_directZDA ) then ! add wind increment at native grid to reduce interpolation error
<           call writewrfvar_native(filename, varstrname, vargrid(:,levels(v_ind-1)+1:levels(v_ind),nb,ne), nlevs)
<        else
<           call readwrfvar(filename, varstrname, enkf_field, nlevs)
<           enkf_field = enkf_field  + vargrid(:,levels(v_ind-1)+1:levels(v_ind),nb,ne)
<           call writewrfvar(filename, varstrname, enkf_field, nlevs)   
<        end if
---
>        call readwrfvar(filename, varstrname, enkf_field, nlevs)
>        enkf_field = enkf_field + vargrid(:,levels(v_ind-1)+1:levels(v_ind),nb,ne)
>        call writewrfvar(filename, varstrname, enkf_field, nlevs)
799,802d785
<        if ( l_use_enkf_directZDA .and. cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(enkf_field(1,1))
<            where (enkf_field < clip) enkf_field = clip
<        end if
810,813d792
<        if ( l_use_enkf_directZDA .and. cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(enkf_field(1,1))
<            where (enkf_field < clip) enkf_field = clip
<        end if
821,824d799
<        if ( l_use_enkf_directZDA .and. cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(enkf_field(1,1))
<            where (enkf_field < clip) enkf_field = clip
<        end if
832,835d806
<        if ( l_use_enkf_directZDA .and. cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(enkf_field(1,1))
<            where (enkf_field < clip) enkf_field = clip
<        end if
843,846d813
<        if ( l_use_enkf_directZDA .and. cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(enkf_field(1,1))
<            where (enkf_field < clip) enkf_field = clip
<        end if
868,871d834
<        if ( l_use_enkf_directZDA .and. cliptracers ) then ! set cliptracers to remove negative hydrometers
<            clip = tiny(enkf_field(1,1))
<            where (enkf_field < clip) enkf_field = clip
<        end if
1290,1410d1252
< 
<   !======================================================================
<   ! writewrfvar_native: write EnKF-style field in WRF netcdf file; 
<   ! analysis increment is interpolated to the native variable grid
<   ! all checks for grid staggering are contained within this subroutine
<   ! CAPS(J. Park): modified from 'writewrfvar_native'
<   !                increments are added at native grid to minimize interpolation
<   !                errors from dot2cross
<   subroutine writewrfvar_native(filename, varname, grid, nlevs)
<     implicit none
<     character(len=500), intent(in) :: filename
<     character(len=12),  intent(in) :: varname
<     integer(i_kind), intent(in) :: nlevs
<     real(r_single),  dimension(npts,nlevs),  intent(in) :: grid    ! analysis increment
< 
<     ! Define variables computed within subroutine
<     real, dimension(:,:,:), allocatable :: workgrid
<     real, dimension(:,:,:), allocatable :: vargrid_native   ! original variables at native grid
<     real, dimension(:,:,:), allocatable :: vargridinc_native ! analysis increment at native grid
<     integer :: xdim, ydim, zdim
<     integer :: xdim_native, ydim_native, zdim_native
<     integer :: xdim_local,  ydim_local,  zdim_local
< 
<     ! Define variables requiredfor netcdf variable I/O
<     character(len=50) :: attstr
<     character(len=12) :: varstagger
< 
<     ! Define counting variables
<     integer :: i, j, k
<     integer :: counth
< 
< 
<     xdim = dimensions%xdim
<     ydim = dimensions%ydim
<     zdim = dimensions%zdim
< 
<     ! Allocate memory for local variable
<     allocate(workgrid(xdim,ydim,zdim))
< 
<     xdim_native = xdim
<     ydim_native = ydim
<     zdim_native = zdim
< 
<     if (arw) then
<        attstr = 'stagger'
<        call variableattribute_char(filename,varname,attstr,     &
<                   & varstagger)
<        !----------------------------------------------------------------------
<        ! If variable grid is staggered, assign array dimensions appropriately
<        if(varstagger(1:1) .eq. 'X') then
<           xdim_native = xdim + 1
<        else if(varstagger(1:1) .eq. 'Y') then
<           ydim_native = ydim + 1
<        else if(varstagger(1:1) .eq. 'Z') then
<           zdim_native = zdim + 1
<        end if ! if(varstagger(1:1) .eq. 'X')
<     endif
< 
<     zdim_local = nlevs
<     if(nlevs == 1) then
<        zdim_native = 1
<     end if
< 
<     ! Define local variable dimensions
<     xdim_local = xdim
<     ydim_local = ydim
< 
<     ! read variables at native grid
<     if (allocated(vargrid_native)) deallocate(vargrid_native)
<     allocate(vargrid_native(xdim_native,ydim_native,zdim_native))
< 
<     ! Ingest variable from external netcdf formatted file
<     call readnetcdfdata(filename,vargrid_native,varname,     &
<             & xdim_native,ydim_native,zdim_native)
< 
<     !----------------------------------------------------------------------
<     ! Allocate memory local arrays (first check whether they are
<     ! already allocated)
<     if (allocated(vargridinc_native)) deallocate(vargridinc_native)
<     allocate(vargridinc_native(xdim_native,ydim_native,zdim_native))
< 
<     !----------------------------------------------------------------------
<     ! Loop through vertical coordinate
<     do k = 1, zdim_local
<        ! Initialize counting variable
<        counth = 1
< 
<        ! Loop through meridional horizontal coordinate
<        do j = 1, ydim
<           ! Loop through zonal horizontal coordinate
<           do i = 1, xdim
<              ! Assign values to local array
<              workgrid(i,j,k) = grid(counth,k)
< 
<              counth = counth + 1
<           end do ! do i = 1, xdim
<        end do ! do j = 1, ydim
<     end do ! k = 1, zdim_local
< 
< 
<     ! Interpolate increments to native grid (i.e., from A-grid to
<     ! C-grid; if necessary); on input, workgrid is increments on
<     ! unstaggered grid; on output vargrid_native is increments on
<     ! model-native (i.e., staggered grid); vargrid_native is
<     ! unmodified first guess on native staggered grid
<     call dot2cross(xdim_local,ydim_local,zdim_local,xdim_native,    &
<             ydim_native,zdim_native,workgrid,vargridinc_native)
< 
<     vargrid_native=vargrid_native+vargridinc_native  ! add Increment
< 
<     !----------------------------------------------------------------------
<     ! Write analysis variable.
<     call writenetcdfdata(filename,vargrid_native,varname,          &
<              xdim_native,ydim_native,zdim_native)
< 
<     ! Deallocate memory for local variables
<     if(allocated(vargrid_native)) deallocate(vargrid_native)
<     if(allocated(vargridinc_native)) deallocate(vargridinc_native)
<     if(allocated(workgrid))       deallocate(workgrid)
< 
<   end subroutine writewrfvar_native
inflation.f90
74c74,75
<                   covinflatenh,covinflatesh,covinflatetr,lnsigcovinfcutoff
---
>                   covinflatenh,covinflatesh,covinflatetr,lnsigcovinfcutoff,&
>                   if_adaptive_inflate,reduced_infl_factor
77c78
< use constants, only: one, zero, rad2deg, deg2rad
---
> use constants, only: one, zero, rad2deg, deg2rad,max_varname_length
81c82
< use loadbal, only: indxproc, numptsperproc, npts_max, anal_chunk, anal_chunk_prior
---
> use loadbal, only: indxproc, numptsperproc, npts_max, anal_chunk, anal_chunk_prior,infm_chunk
280c281,295
<    anal_chunk(:,i,nn,nb) = tmp_chunk2(i,nn)*anal_chunk(:,i,nn,nb)
---
>    if(if_adaptive_inflate)then
>      if ( nn == ncdim ) then ! ps
>          nnlvl=1
>      else
>          nnlvl=nn - nn/nlevs*nlevs
>      end if
>      if( nnlvl == 0 ) nnlvl = nlevs
>      if(infm_chunk(i,nnlvl) >= 90.0)then
>        anal_chunk(:,i,nn,nb) = reduced_infl_factor*tmp_chunk2(i,nn)*anal_chunk(:,i,nn,nb)
>      else
>        anal_chunk(:,i,nn,nb) = tmp_chunk2(i,nn)*anal_chunk(:,i,nn,nb)
>      end if
>    else
>      anal_chunk(:,i,nn,nb) = tmp_chunk2(i,nn)*anal_chunk(:,i,nn,nb)
>    end if
innovstats.f90
222c222
<    call printstats('  all  oz',sumoz_nh,biasoz_nh,sumoz_spread_nh,sumoz_oberr_nh,nobsoz_nh,&
---
>    call printstats(' sbuv2 oz',sumoz_nh,biasoz_nh,sumoz_spread_nh,sumoz_oberr_nh,nobsoz_nh,&
kdtree2.f90
letkf.f90
110c110
< use constants, only: pi, one, zero, rad2deg, deg2rad, rearth
---
> use constants, only: pi, one, zero, rad2deg, deg2rad
116c116
<                   neigv,vlocal_evecs,dfs_sort,mincorrlength_fact
---
>                   neigv,vlocal_evecs,dfs_sort
138,142c138,139
<                 nobslocal_mean,nobslocal_min,nobslocal_max, &
<                 nobslocal_meanall,nobslocal_minall,nobslocal_maxall
< real(r_single)  robslocal_mean,robslocal_min,robslocal_max,re, &
<                 robslocal_meanall,robslocal_minall,robslocal_maxall,&
<                 coslatslocal_meanall, coslatslocal_mean, coslat
---
>                 nobslocal_min,nobslocal_max, &
>                 nobslocal_minall,nobslocal_maxall
144c141
< real(r_single) :: deglat, dist, corrsq, trpa, trpa_raw, maxdfs
---
> real(r_single) :: deglat, dist, corrsq, oberrfact, trpa, trpa_raw
147c144
< real(r_kind) normdepart, pnge, width, mincorrlength_factsq
---
> real(r_kind) normdepart, pnge, width
158c155
< real(r_kind),allocatable,dimension(:) :: rdiag,rloc,robs_local,coslats_local
---
> real(r_kind),allocatable,dimension(:) :: rdiag,rloc
166d162
< re = rearth/1.e3_r_single
177d172
< mincorrlength_factsq = mincorrlength_fact**2
266d260
< 
269,275d262
< nobslocal_mean = 0
< allocate(robs_local(npts_max))
< robs_local = 0
< if (nobsl_max > 0) then
<   allocate(coslats_local(npts_max))
<   coslats_local = 0
< endif
279,281c266,268
< !$omp parallel do schedule(dynamic) default(none) private(npt,nob,nobsl, &
< !$omp                  nobsl2,ngrd1,corrlength,ens_tmp,coslat, &
< !$omp                  nf,vdist,obens,indxassim,indxob,maxdfs, &
---
> !$omp parallel do schedule(dynamic) private(npt,nob,nobsl, &
> !$omp                  nobsl2,oberrfact,ngrd1,corrlength,ens_tmp, &
> !$omp                  nf,vdist,obens,indxassim,indxob, &
283,293c270,271
< !$omp                  oindex,deglat,dist,corrsq,nb,nlev,nanal,sresults, &
< !$omp                  wts_ensperts,pa,trpa,trpa_raw) shared(anal_ob, &
< !$omp                  anal_ob_modens,anal_chunk,obsprd_post,obsprd_prior, &
< !$omp                  oberrvar,oberrvaruse,nobsl_max,grdloc_chunk, &
< !$omp                  obloc,corrlengthnh,corrlengthsh,corrlengthtr,&
< !$omp                  vlocal_evecs,vlocal,oblnp,lnp_chunk,lnsigl,corrlengthsq,&
< !$omp                  getkf,denkf,getkf_inflation,ensmean_chunk,ob,ensmean_ob, &
< !$omp                  nproc,numptsperproc,nnmax,r_nanalsm1,kdtree_obs2,kdobs, &
< !$omp                  mincorrlength_factsq,robs_local,coslats_local, &
< !$omp                  lupd_obspace_serial,eps,dfs_sort,nanals,index_pres,&
< !$omp  neigv,nlevs,lonsgrd,latsgrd,nobstot,nens,ncdim,nbackgrounds,indxproc,rad2deg) &
---
> !$omp                  oindex,deglat,dist,corrsq,nb,sresults, &
> !$omp                  wts_ensperts,pa,trpa,trpa_raw) &
304d281
<    coslat = cos(latsgrd(ngrd1))
330d306
<           maxdfs = -9.9e31
333c309
<              dist = sqrt(rloc(nob)/corrsq)
---
>              dist = sqrt(rloc(nob)/corrlengthsq(nob))
338,344c314,325
<                 ! use updated ensemble in ob space to compute DFS
<                 ! DFS = Tr(R**-1*HPaHT) = dy_a/dy_o see eqn 4 in Liu et al 2009
<                 ! https://rmets.onlinelibrary.wiley.com/doi/epdf/10.1002/qj.511
<                 dfs(nobsl) = obsprd_post(nob)/oberrvaruse(nob)
<                 ! use spread reduction instead.
<                 !dfs(nobsl) = obsprd_post(nob)/obsprd_prior(nob)
<                 !if (dfs(nobsl) > maxdfs) maxdfs = dfs(nobsl)
---
>                 oberrfact = taper(dist)
>                 if (lupd_obspace_serial) then
>                    ! use updated ensemble in ob space to estimate DFS
>                    !dfs(nobsl) = obsprd_post(nob)/obsprd_prior(nob)
>                    ! weight by distance to analysis point
>                    dfs(nobsl) = oberrfact*obsprd_post(nob)/obsprd_prior(nob)
>                 else
>                    ! estimate DFS assuming each ob assimilated independently, one
>                    ! at a time.
>                    ! 1-DFS = HP_aH^T/HP_bH^T = R/(HP_bH^T + R)
>                    dfs(nobsl) = (oberrvaruse(nob)/oberrfact)/((oberrvar(nob)/oberrfact)+obsprd_prior(nob))
>                 endif
347c328
<           ! sort on max(DFS)-DFS
---
>           ! sort on 1-DFS
349d329
<           dfs = maxdfs-dfs
367a348
>              nobsl_max = nobsl
394,399d374
<    if (nobsl_max > 0) then
<       robs_local(npt) = sqrt(sresults(nobsl)%dis)
<       coslats_local(npt) = coslat
<    else
<       robs_local(npt) = nobsl
<    endif
418,431c393
<          if (nobsl_max > 0 .and. corrlength < 0) then
<              ! if corrlength<0, set R localization scale to be max distance to find nobsl_max obs
<              ! (unless max distance is > abs(corrlength) or < abs(corrlength)/10)
<              if (sresults(nobsl)%dis > corrsq) then
<                 dist = sqrt(sresults(nob)%dis/corrsq+vdist*vdist)
<              else if (sresults(nobsl)%dis < corrsq*mincorrlength_factsq) then
<                 dist = sqrt(sresults(nob)%dis/(corrsq/mincorrlength_factsq)+vdist*vdist)
<              else
<                 dist = sqrt(sresults(nob)%dis/sresults(nobsl)%dis+vdist*vdist)
<              endif
<          else
<              ! set R localization scale to specificed distance
<              dist = sqrt(sresults(nob)%dis/corrsq+vdist*vdist)
<          endif
---
>          dist = sqrt(sresults(nob)%dis/corrlengthsq(nf)+vdist*vdist)
531,533c493
< !$omp parallel do schedule(dynamic) default(none) private(npt,nb,i) &
< !$omp                               shared(anal_chunk,r_nanals,nanals,&
< !$omp                               npts_max,nbackgrounds,ncdim)
---
> !$omp parallel do schedule(dynamic) private(npt,nb,i)
572,594d531
< 
< if (nobsl_max > 0) then
<    ! compute and print min/max/mean search radius to find nobsl_max
<    robslocal_mean = sum(robs_local*coslats_local)/numptsperproc(nproc+1)
<    coslatslocal_mean = sum(coslats_local)/numptsperproc(nproc+1)
<    robslocal_min = minval(robs_local(1:numptsperproc(nproc+1)))
<    robslocal_max = maxval(robs_local(1:numptsperproc(nproc+1)))
<    call mpi_reduce(robslocal_max,robslocal_maxall,1,mpi_real4,mpi_max,0,mpi_comm_world,ierr)
<    call mpi_reduce(robslocal_min,robslocal_minall,1,mpi_real4,mpi_min,0,mpi_comm_world,ierr)
<    call mpi_reduce(robslocal_mean,robslocal_meanall,1,mpi_real4,mpi_sum,0,mpi_comm_world,ierr)
<    call mpi_reduce(coslatslocal_mean,coslatslocal_meanall,1,mpi_real4,mpi_sum,0,mpi_comm_world,ierr)
<    if (nproc == 0) print *,'min/max/mean distance searched for local obs',re*robslocal_minall,re*robslocal_maxall,re*robslocal_meanall/coslatslocal_meanall
<    deallocate(coslats_local)
< else
<    ! compute and print min/max/mean number of obs found within search radius
<    nobslocal_mean = nint(sum(robs_local)/numptsperproc(nproc+1))
<    nobslocal_min = minval(robs_local(1:numptsperproc(nproc+1)))
<    nobslocal_max = maxval(robs_local(1:numptsperproc(nproc+1)))
<    call mpi_reduce(nobslocal_max,nobslocal_maxall,1,mpi_integer,mpi_max,0,mpi_comm_world,ierr)
<    call mpi_reduce(nobslocal_min,nobslocal_minall,1,mpi_integer,mpi_min,0,mpi_comm_world,ierr)
<    call mpi_reduce(nobslocal_mean,nobslocal_meanall,1,mpi_integer,mpi_sum,0,mpi_comm_world,ierr)
<    if (nproc == 0) print *,'min/max/mean number of obs in local volume',nobslocal_minall,nobslocal_maxall,nint(nobslocal_meanall/float(numproc))
< endif
598d534
< 
600d535
< deallocate(robs_local)
loadbal.f90
106c106,107
<                   neigv, corrlengthnh, corrlengthsh, corrlengthtr, lupd_obspace_serial,letkf_bruteforce_search
---
>                   neigv, corrlengthnh, corrlengthsh, corrlengthtr, lupd_obspace_serial,letkf_bruteforce_search,&
>                   if_adaptive_inflate,nlevs
112c113
< use gridinfo, only: gridloc, logp, latsgrd, nlevs_pres, npts
---
> use gridinfo, only: gridloc, logp, latsgrd, nlevs_pres, npts, inflation_mask
121c122,123
<                                                       anal_obchunk_modens_prior
---
>                                                       anal_obchunk_modens_prior,&
>                                                       infm_chunk
242a245,253
> if( if_adaptive_inflate )then
>   allocate(infm_chunk(numptsperproc(nproc+1),nlevs))
>   do i=1,numptsperproc(nproc+1)
>      do nn=1,nlevs
>        infm_chunk(i,nn) = inflation_mask(indxproc(nproc+1,i),nn)
>      end do
>   end do
> end if
> 
386c397
< if (nproc == 0) print *,'anal_chunk size = ',size(anal_chunk,kind=8)
---
> if (nproc == 0) print *,'anal_chunk size = ',size(anal_chunk)
445a457,458
> 
> 
mpi_readobs.f90
253,264c253
<        if (real(nanals)*real(nobs_tot) < 2**32/2. - 1) then
<           call mpi_allreduce(mpi_in_place,anal_ob,nanals*nobs_tot,mpi_real4,mpi_sum,mpi_comm_shmemroot,ierr)
<        else
<           ! count won't fit in 32-bit integer and mpi_allreduce doesn't handle
<           ! 64 bit counts.  Split up into smaller chunks.
<           mem_ob = 0.
<           do na=1,nanals
<               mem_ob(:) = anal_ob(na,:)
<               call mpi_allreduce(mpi_in_place,mem_ob,nobs_tot,mpi_real4,mpi_sum,mpi_comm_shmemroot,ierr)
<               anal_ob(na,:) = mem_ob(:)
<           enddo
<        endif
---
>        call mpi_allreduce(mpi_in_place,anal_ob,nanals*nobs_tot,mpi_real4,mpi_sum,mpi_comm_shmemroot,ierr)
286a276
> !$omp parallel do private(nob)
289a280
> !$omp end parallel do
290a282
> !$omp parallel do private(nob)
295a288
> !$omp end parallel do
296a290
> !$omp parallel do private(nob)
299a294
> !$omp end parallel do
302a298
> !$omp parallel do private(nob)
306a303
> !$omp end parallel do
308a306
> !$omp parallel do private(nob)
311a310
> !$omp end parallel do
mpisetup.f90
netcdf_io_wrf.f90
observer_fv3reg.f90
observer_gfs.f90
observer_nmmb.f90
observer_reg.f90
observer_wrf.f90
params.f90
33,35d32
< !   2018-11-15  groff - Added ancillary parameters
< !                       for EFSOI calculations
< !   2019-03-20  CAPS(C. Tong) - added variables direct reflectivity DA capability
61,67d57
< ! EFSOI file type identifiers
< integer(i_kind), public, parameter :: read_ensmean_forecast = 0
< integer(i_kind), public, parameter :: read_analysis_mean = 1
< integer(i_kind), public, parameter :: read_member_forecasts = 2
< integer(i_kind), public, parameter :: read_verification = 3
< ! Analysis impact specific file type identifier
< integer(i_kind), public, parameter :: read_member_analyses = 2
91,94d80
< ! Hour for datestring
< integer(i_kind), public :: datehr, gdatehr
< ! analysis filename, needed for EFSOI calcs
< character(len=100), public ::  andataname
109,110d94
< integer(i_kind),public :: eft
< integer(i_kind),public :: tar_minlev,tar_maxlev
118,120d101
< ! factor for minimum allowed horiz cov length scale
< ! to apply for LETKF when corrlengthnh,tr,sh < 0 and nobsl_max > 0
< real(r_single),public ::  mincorrlength_fact = 0.1
125,126d105
< real(r_single),public ::  corrlengthrdrnh,corrlengthrdrtr,corrlengthrdrsh, &
<                lnsigcutoffrdrnh,lnsigcutoffrdrtr,lnsigcutoffrdrsh
131,132d109
< real(r_single),public :: wmoist,adrate
< real(r_single),public :: tar_minlat,tar_maxlat,tar_minlon,tar_maxlon
135,138c112
< real(r_single),public :: covinflatenh=0
< real(r_single),public :: covinflatetr=0
< real(r_single),public :: covinflatesh=0
< real(r_single),public :: lnsigcovinfcutoff
---
> real(r_single),public :: covinflatenh,covinflatesh,covinflatetr,lnsigcovinfcutoff
200,204d173
< 
< ! EFSOI ancillary flag to determine
< ! type of impact estimate/calculation
< logical,public :: forecast_impact = .true.
< 
207,210d175
< ! additional flag for EnKF when using diagnostics from direct reflectivity DA capability
< ! this flag was set not to affect the other applications.
< ! this flag mainly affects in reading obs diagnostics and writing anlysis file
< logical,public :: l_use_enkf_directZDA = .false.
220,221c185,186
< ! required for EFSOI calculations
< logical,public :: efsoi_cycling = .false.
---
> ! required for EFSO calculations
> logical,public :: fso_cycling = .false.
223,225c188,189
< ! Ancillary flag, applied only for
< ! EFSOI calculation applications
< logical,public :: efsoi_flag = .false.
---
> ! if true perform efso calculations
> logical,public :: fso_calculate = .false.
254,255c218,221
< ! write ensemble mean analysis (or analysis increment)
< logical,public :: write_ensmean = .false.
---
> 
> ! for adaptive RTPS
> logical,public :: if_adaptive_inflate = .false.
> real(r_single) :: reduced_infl_factor = 1.0
259c225
<                    mincorrlength_fact,corrlengthnh,corrlengthtr,corrlengthsh,&
---
>                    corrlengthnh,corrlengthtr,corrlengthsh,&
276c242
<                    save_inflation,nobsl_max,lobsdiag_forenkf,netcdf_diag,forecast_impact,&
---
>                    save_inflation,nobsl_max,lobsdiag_forenkf,netcdf_diag,&
280,287c246,248
<                    efsoi_cycling,efsoi_flag,imp_physics,lupp,cnvw_option,use_correlated_oberrs,&
<                    eft,wmoist,adrate,andataname,&
<                    gdatehr,datehr,&
<                    tar_minlat,tar_maxlat,tar_minlon,tar_maxlon,tar_minlev,tar_maxlev,&
<                    fv3_native, paranc, nccompress, write_fv3_incr,incvars_to_zero,write_ensmean, &
<                    corrlengthrdrnh,corrlengthrdrsh,corrlengthrdrtr,&
<                    lnsigcutoffrdrnh,lnsigcutoffrdrsh,lnsigcutoffrdrtr,&
<                    l_use_enkf_directZDA
---
>                    fso_cycling,fso_calculate,imp_physics,lupp,cnvw_option,use_correlated_oberrs,&
>                    fv3_native, paranc, nccompress, write_fv3_incr,incvars_to_zero,&
>                    if_adaptive_inflate,reduced_infl_factor
304,307d264
< ! default analysis hour
< datehr = 00
< ! Initial hour for background forecasts
< gdatehr = 00
317,320d273
< ! corrlength for radar (length for horizontal localization in km)
< corrlengthrdrnh = 10
< corrlengthrdrtr = 10
< corrlengthrdrsh = 10
342,344d294
< lnsigcutoffrdrnh = 0.2_r_single  ! value for radar
< lnsigcutoffrdrtr = 0.2_r_single  ! value for radar
< lnsigcutoffrdrsh = 0.2_r_single  ! value for radar
405,407d354
< ! nvars is numer of 3d variables to update.
< ! for hydrostatic models, typically 5 (u,v,T,q,ozone).
< nvars = 5
416,431d362
< ! Evaluation FT for EFSOI
< eft = 24
< ! Weigt for moist total energy norm (0 when dry total energy)
< ! applied in EFSOI calculation
< wmoist = 0.0_r_single
< ! Advection coefficient for localization function
< adrate = 0.0_r_single
< ! Name of analysis file at EFSOI evaluation time
< andataname=''
< ! Target area for observation impact computation
< tar_minlat = -90.0_r_single
< tar_maxlat = 90.0_r_single
< tar_minlon = 0.0_r_single
< tar_maxlon = 360.0_r_single
< tar_minlev = 0
< tar_maxlev = 0
675,678d605
<    if ((write_ensmean .and. pseudo_rh) .and. .not. use_qsatensmean) then
<       print *,'write_ensmean=T requires use_qsatensmean=T when pseudo_rh=T'
<       call stop2(19)
<    endif
792,812d718
< ! rescale covariance localization length for radar observations
< ! note:(1) in namelist, the length is in unit of kilometer;
< !      (2) here it is converted to be in unit of meter,
< !      (3) then, it is re-scaled by radius of earth
< !          (actually it is non-dimensionalized).
< corrlengthrdrnh = corrlengthrdrnh * 1.e3_r_single/rearth
< corrlengthrdrtr = corrlengthrdrtr * 1.e3_r_single/rearth
< corrlengthrdrsh = corrlengthrdrsh * 1.e3_r_single/rearth
< 
< ! convert targe area boundary into radians
< tar_minlat = tar_minlat * deg2rad
< tar_maxlat = tar_maxlat * deg2rad
< tar_minlon = tar_minlon * deg2rad
< tar_maxlon = tar_maxlon * deg2rad
< 
< ! use default vertical levels
< tar_maxlev = min(nlevs,tar_maxlev)
< if(tar_minlev < 1 .or. tar_maxlev < 1 .or. tar_maxlev < tar_minlev) then
<    tar_minlev = 1
<    tar_maxlev = nlevs
< end if
quicksort.f90
radbias.f90
readconvobs.f90
26d25
< !   2019-03-21  CAPS(C. Tong) - added direct reflectivity DA capability
35c34
< use params, only: npefiles, netcdf_diag, modelspace_vloc, l_use_enkf_directZDA
---
> use params, only: npefiles, netcdf_diag, modelspace_vloc
338,340c337
<            if (obtype == 'gps') then
<                if (GPS_Type(i)==1) errorlimit2=errorlimit2_bnd
<            endif
---
>            if (obtype == 'gps' .and. GPS_Type(i)==1) errorlimit2=errorlimit2_bnd
667,669c664
<            if (obtype == 'gps') then
<               if (GPS_Type(i)==1) errorlimit2=errorlimit2_bnd
<            endif
---
>            if (obtype == 'gps' .and. GPS_Type(i)==1) errorlimit2=errorlimit2_bnd
1076,1135d1070
< !   direct reflectivitiy DA has a different routine for dbz obs.
<      if (l_use_enkf_directZDA .and. obtype == 'dbz' ) then
<        allocate(cdiagbuf(ii),rdiagbuf(nreal,ii))
<        read(iunit) cdiagbuf(1:ii),rdiagbuf(:,1:ii)
< 
<        if(twofiles)then
<           allocate(cdiagbuf2(ii2), rdiagbuf2(nreal2,ii2))
<           read(iunit2) cdiagbuf2(1:ii2),rdiagbuf2(:,1:ii2)
<        end if
< 
<        do n=1,ii
<           nobdiag = nobdiag + 1
<           if(rdiagbuf(12,n) < zero .or. rdiagbuf(16,n) < errorlimit .or. &
<              rdiagbuf(16,n) > errorlimit2)cycle
<           if(abs(rdiagbuf(17,n)) > 1.e9_r_kind  .or. &
<                rdiagbuf(6,n) < 0.001_r_kind .or. &
<                rdiagbuf(6,n) > 1200._r_kind) cycle
<           if(twofiles)then
<           if(rdiagbuf(1,n) /= rdiagbuf2(1,n) .or. abs(rdiagbuf(3,n)-rdiagbuf2(3,n)) .gt. 1.e-5_r_kind .or. &
<              abs(rdiagbuf(4,n)-rdiagbuf2(4,n)) .gt. 1.e-5_r_kind .or. abs(rdiagbuf(8,n)-rdiagbuf2(8,n)) .gt. 1.e-5_r_kind)then
<              write (6,*) obtype, ' conv ob data inconsistency '
<              write (6,*) (rdiagbuf(i,n),i=1,8)
<              write (6,*) (rdiagbuf2(i,n),i=1,8)
<              call stop2(94)
<           end if
<           end if
< 
<           nob = nob + 1
<           x_used(nobdiag) = 1
<           x_code(nob)    = rdiagbuf(1,n)
<           x_lat(nob)     = rdiagbuf(3,n)
<           x_lon(nob)     = rdiagbuf(4,n)
<           x_press(nob)   = rdiagbuf(6,n)
<           x_time(nob)    = rdiagbuf(8,n)
<           if (rdiagbuf(14,n) > 1.e-5_r_kind) then
<             x_errorig(nob) = (one/rdiagbuf(14,n))**2
<           else
<             x_errorig(nob) = 1.e10_r_kind
<           endif
<           x_err(nob) = (one/rdiagbuf(16,n))**2
<           x_obs(nob) = rdiagbuf(17,n)
<           hx_mean(nob)      = rdiagbuf(17,n)-rdiagbuf(18,n)
<           hx_mean_nobc(nob) = rdiagbuf(17,n)-rdiagbuf(19,n)
<           x_type(nob) = obtype
<           ! get Hx
<           if (nanal <= nanals) then
<             ! read full Hx from file
<             if (.not. lobsdiag_forenkf) then
<               hx(nob) = rdiagbuf(17,n) - rdiagbuf2(18,n)
<             else ! Linearized Hx not supported for dbz yet
<               write(6,*)'Current dbz DA code does NOT support lobsdiag_forenkf yet!'
<               write(6,*)'BREAK HERE...'
<               call stop2(94)
<             endif
<           endif
<        enddo
<        deallocate(cdiagbuf,rdiagbuf)
<        if(twofiles)deallocate(cdiagbuf2,rdiagbuf2)
<      else
< 
1232c1167
<           if (obtype == 'dbz')   x_type(nob) = 'dbz'
---
>           if (obtype == 'dbz')  x_type(nob) = 'dbz'
1370c1305
<      end if ! end of .not. l_use_enkf_directZDA flag
---
> 
read_fv3reg_restarts.f90
45c45
<        data_arr=data_arr(ubound(data_arr,1):lbound(data_arr,1):-1,ubound(data_arr,2):lbound(data_arr,2):-1)
---
>        data_arr=data_arr(lbound(data_arr,1):ubound(data_arr,1),lbound(data_arr,2):ubound(data_arr,2))
59c59
<        data_arr=data_arr(ubound(data_arr,1):lbound(data_arr,1):-1,ubound(data_arr,2):lbound(data_arr,2):-1, &
---
>        data_arr=data_arr(lbound(data_arr,1):ubound(data_arr,1),lbound(data_arr,2):ubound(data_arr,2), &
read_locinfo.f90
readozobs.f90
929c929
<                     nf90_inquire_dimension, NF90_WRITE, NF90_NOWRITE, nf90_create, nf90_def_dim
---
>                     nf90_inquire_dimension, NF90_WRITE, nf90_create, nf90_def_dim
975c975
<          call nclayer_check(nf90_open(obsfile, NF90_NOWRITE, iunit))
---
>          call nclayer_check(nf90_open(obsfile, NF90_WRITE, iunit))
readsatobs.f90
1263c1263
<                     nf90_inquire_dimension, NF90_WRITE, NF90_NOWRITE, nf90_create, nf90_def_dim
---
>                     nf90_inquire_dimension, NF90_WRITE, nf90_create, nf90_def_dim
1329c1329
<      call nclayer_check(nf90_open(obsfile, NF90_NOWRITE, iunit))
---
>      call nclayer_check(nf90_open(obsfile, NF90_WRITE, iunit))
reducedgrid.f90
rnorm.f90
smooth_fv3reg.f90
smooth_gfs.f90
smooth_nmmb.f90
smooth_wrf.f90
sorting.f90
specmod.f90
specmod_shtns.f90
specmod_splib.f90
statevec.f90
write_fv3reg_restarts.f90
55c55
<        data_arr=data_arr(ubound(data_arr,1):lbound(data_arr,1):-1,ubound(data_arr,2):lbound(data_arr,2):-1, &
---
>        data_arr=data_arr(lbound(data_arr,1):ubound(data_arr,1),lbound(data_arr,2):ubound(data_arr,2), &
write_logfile.f90
